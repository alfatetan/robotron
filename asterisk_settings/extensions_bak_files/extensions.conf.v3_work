[zadarma-in]

	;назначаем основные переменные:
	;sayfile - содержит имя файла, проигрываемого системой
	;saybranch - содержит имя ветки диалога, равное названию с расширением .json
	;sayindex - содержит текущую позицию диалога, по которой происходит этот цикл
	;voicefile - имя файла, где записан голос абонента
	;count - счетчик для формирования voicefile
	;prefix - префикс для формирования voicefile
	;skip - пропустить выслушивание абонента: просто сказать и перейти в следующий цикл
exten => 590889, 1, Set(prefix=voice)
exten => 590889, n, Set(count=0)
exten => 590889, n, Set(sayindex=0)
exten => 590889, n, Set(saybranch=trunk)
exten => 590889, n, Set(sayfile=begin)
;exten => 590889, n, Set(skip=0)

	;берём трубку
exten => 590889, n, Answer()

;--------------- ВРЕМЕННО ДЕАКТИВИРОВАННЫЙ КУСОК КОДА -----------------
	;один из вариантов - запустить запись перед началом разговора. Нужно тестировать какой более эффективен
;exten => 590889, 4, Monitor(wav, clientvoice, o) ; Чтобы уменьшить задержку, необходимо два раза включать монитор
;один раз после произнесения звука, второй раз - если абонент перебил. Обратить внимание на приоритеты!
;----------------------------------------------------------------------

	;произносим пламенную речь и даём возможность перебить абоненту
;exten => 590889,n(sayanything),BackgroundDetect(my/name, 150)
exten => 590889,n(sayanything),BackgroundDetect(my/${sayfile})

;---------ВРЕМЕННО ДЕАКТИВИРОВАННЫЙ КУСОК КОДА---------------
	;если нам нужно не слушать абонента, пропускаем диалог
;exten => 590889, n, GotoIf($[${skip} = 0]?:nextstep)
;------------------ТРЕБУЕТСЯ ДОРАБОТКА-----------------------

	;чтобы укоротить запись, начинаем её под конец произношения нашей пламенной речи. Т.о. файл будет короче
exten => 590889, n, Monitor(wav, clientvoice, o)

	;нас выслушали, теперь мы ожидаем когда абонент начнёт говорить. 0 - бесконечно молчим в секундах
exten => 590889, n, WaitForNoise(150, 1, 0)

	;пока наш абонент говорит, мы ждём, пока он не замолчит на секунду с четвертью.
;exten => 590889, n, WaitForSilence(1500, 1, 0, 150)
exten => 590889, n, WaitForSilence(1250, 1, 0)

	;записываем полученный разговор в новый файл. Тут необходимо поработать с содержимым переменных
exten => 590889, n, Set(count=$[${count} + 1])
exten => 590889, n, Set(voicefile=${prefix}-${count})
exten => 590889, n, ChangeMonitor(${voicefile})
exten => 590889, n, StopMonitor()

	;запускаем внешний обработчик, в итоге получаем относительно DialPlan:
	;STDOUT: куча всякой ненужной хрени, sayindex, saybranch, voicefile
	;STDIN: sayfile, syabranch, sayindex
exten => 590889, n, AGI(say_agi.agi)

	;проверяем, если sayfile содержит end, то завершаем разговор
exten => 590889, n, GotoIf($[${sayfile} = end]?:sayanything)
;exten => 590889, n, Goto(4) ; здесь необходимо использовать конструкцию GotoIf, чтобы понять когда разговор заканчивается. Goto - временная

exten => 590889, n, SendDTMF(123) ; временный сигнал для отладки, что всё прошло как нужно

	;разговор окончен, разъединяем
exten => 590889, n, Hangup()

	;если абонент любит перебивать (эту часть необходимо доработать 2019.04.10):
exten => talk, 1, Monitor(wav, clientvoice, o)
exten => talk, n, Playback(my/aga.wav)
exten => 590889, n, WaitForSilence(2000, 1, 3) ; ждём пока абонент замолчит на 2 секунды
exten => 590889, n, ChangeMonitor(${nextfname})
exten => 590889, n, StopMonitor()
exten => 590887, Goto(sayanything)
	;!!!!!здесь, по логике вещей - должен висеть внешний обработчик 


[zadarma-out]
exten => _XXX,1,Dial(SIP/${EXTEN})                     ; звонки на трехзначные внутренние номера aстериска
exten => _XXX.,1,Dial(SIP/${EXTEN}@590889)             ; звонки на номера в которых четрые и более цифр через транк 590889

[calls]
